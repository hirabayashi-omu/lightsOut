<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Lights Out スマホ対応版</title>
<style>
  body {
    background: url('imgs2/parts.png') center/cover no-repeat;
    color: white;
    text-align: center;
    font-family: sans-serif;
    margin:0; padding:0;
  }
  canvas {
    background: #222;
    display: block;
    margin: 10px auto;
    touch-action: none; /* スマホでスクロール防止 */
  }
  button, select {
    font-size: 18px; padding: 8px 14px; margin: 6px;
  }
</style>
</head>
<body>
<h2>Lights Out</h2>

<select id="sizeSel">
  <option value="4">4×4</option>
  <option value="5" selected>5×5</option>
  <option value="6">6×6</option>
  <option value="7">7×7</option>
  <option value="8">8×8</option>
  <option value="9">9×9</option>
  <option value="10">10×10</option>
  <option value="12">12×12</option>
  <option value="15">15×15</option>
  <option value="20">20×20</option>
</select>

<button id="regenBtn">盤面再生成</button>
<button id="hintBtn">ヒント表示</button>
<button id="autoBtn">自動解答</button>

<canvas id="canvas"></canvas>

<script>
// -----------------------------
// 定数・グローバル
// -----------------------------
const TOP_MARGIN = 60;
const ANIM_DT = 0.06;

let GRID_N = 5;
let CELL = 60;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let grid=[], solution=[], tileImgMap=[];
let showHint=false;
let animations=[], autoSeq=[], autoIndex=0, autoRun=false, sparkles=[];

// 音
let flipSound=null, clickSound=null;
try{ flipSound=new Audio("flip.mp3"); }catch(e){}
try{ clickSound=new Audio("click.mp3"); }catch(e){}

// タイル表画像
const frontImgs=[];
for(let i=1;i<=20;i++){
  const img=new Image(); img.src=`imgs/${i}.png`; frontImgs.push(img);
}
// タイル裏画像
const backImg = new Image(); backImg.src = "imgs2/kt.png";

// -----------------------------
// スパークル（強化版）
// -----------------------------
class Sparkle{
  constructor(x,y,lifetime=0.35){
    this.x=x; this.y=y; this.time=0; this.lifetime=lifetime; this.radius=0;
    this.extraR=Math.random()*20;
  }
  update(dt){ this.time+=dt; this.radius=10 + 140*(this.time/this.lifetime)+this.extraR; }
  isDead(){ return this.time>=this.lifetime; }
  draw(ctx){
    const alpha=Math.max(0,0.8*(1-this.time/this.lifetime));
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,2*Math.PI);
    ctx.strokeStyle=`rgba(255,255,180,${alpha})`;
    ctx.lineWidth=4; ctx.stroke();
  }
}

// -----------------------------
// 盤面生成（必ず解ける）
// -----------------------------
function generateSolvableBoard(n){
  let b = Array.from({length:n},()=>Array(n).fill(0));
  const moves=Math.floor(Math.random()*(n*n))+n;
  for(let i=0;i<moves;i++){
    const x=Math.floor(Math.random()*n), y=Math.floor(Math.random()*n);
    applyLogicalToggle(b,x,y);
  }
  return b;
}
function applyLogicalToggle(board,x,y){
  [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
    let nx=x+dx, ny=y+dy;
    if(nx>=0 && nx<board.length && ny>=0 && ny<board.length) board[ny][nx]^=1;
  });
}

// タイル画像割り当て
function assignTileImages(){
  tileImgMap = Array.from({length:GRID_N},()=>Array(GRID_N).fill(0));
  for(let y=0;y<GRID_N;y++){
    for(let x=0;x<GRID_N;x++){
      tileImgMap[y][x] = Math.floor(Math.random()*frontImgs.length);
    }
  }
}

// -----------------------------
// GF(2) ソルバー
// -----------------------------
function solveGF2(board){
  const N=GRID_N*GRID_N;
  let A=Array.from({length:N},()=>Array(N).fill(0)), b=[];
  for(let y=0;y<GRID_N;y++){
    for(let x=0;x<GRID_N;x++){
      const idx=y*GRID_N+x;
      [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
        const nx=x+dx, ny=y+dy;
        if(nx>=0 && nx<GRID_N && ny>=0 && ny<GRID_N) A[idx][ny*GRID_N+nx]=1;
      });
      b.push(board[y][x]);
    }
  }
  for(let i=0;i<N;i++){
    if(A[i][i]===0){
      for(let j=i+1;j<N;j++){ if(A[j][i]===1){ [A[i],A[j]]=[A[j],A[i]]; [b[i],b[j]]=[b[j],b[i]]; break;} }
    }
    for(let j=0;j<N;j++){
      if(i!==j && A[j][i]===1){
        for(let k=0;k<N;k++) A[j][k]^=A[i][k]; b[j]^=b[i];
      }
    }
  }
  let sol=Array.from({length:GRID_N},()=>Array(GRID_N).fill(0));
  for(let i=0;i<N;i++) sol[Math.floor(i/GRID_N)][i%GRID_N]=b[i];
  return sol;
}

// -----------------------------
// キャンバスサイズ
// -----------------------------
function adjustCanvasSize(){
  const maxW=window.innerWidth*0.9, maxH=window.innerHeight*0.75;
  CELL=Math.max(10,Math.floor(Math.min(maxW/GRID_N,(maxH-TOP_MARGIN)/GRID_N)));
  canvas.width=CELL*GRID_N; canvas.height=CELL*GRID_N+TOP_MARGIN;
}

// -----------------------------
// 新盤面
// -----------------------------
function newBoard(){
  GRID_N=Number(document.getElementById("sizeSel").value)||GRID_N;
  grid=generateSolvableBoard(GRID_N);
  solution=solveGF2(grid);
  showHint=false; animations=[]; sparkles=[]; autoSeq=[]; autoIndex=0; autoRun=false;
  adjustCanvasSize(); assignTileImages(); draw();
}

// -----------------------------
// クリック・タッチ処理
// -----------------------------
function pressAt(x,y){
  if(flipSound){ flipSound.currentTime=0; flipSound.play(); }
  if(clickSound){ clickSound.currentTime=0; clickSound.play(); }

  [[0,0],[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
    const nx=x+dx, ny=y+dy;
    if(nx>=0 && nx<GRID_N && ny>=0 && ny<GRID_N){
      const oldVal = grid[ny][nx];
      const newVal = oldVal ^ 1;
      animations.push({x:nx,y:ny,t:0,oldVal,newVal});
    }
  });

  for(let i=0;i<2+Math.floor(Math.random()*2);i++){
    sparkles.push(new Sparkle(x*CELL+CELL/2, y*CELL+CELL/2+TOP_MARGIN));
  }
}

// -----------------------------
// 描画
// -----------------------------
function drawCellScaled(px,py,w,h,val,scale,ix,iy){
  ctx.save();
  const cx=px+w/2, cy=py+h/2; ctx.translate(cx,cy); ctx.scale(1,scale); ctx.translate(-cx,-cy);
  const img = (scale<0.5) ? backImg : (val ? frontImgs[tileImgMap[iy][ix]] : backImg);
  ctx.drawImage(img, px, py + (h - h*scale)/2, w, h*scale);
  ctx.strokeStyle="#666"; ctx.lineWidth=1; ctx.strokeRect(px, py + (h - h*scale)/2, w, h*scale);
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  let remain=0; for(let y=0;y<GRID_N;y++) for(let x=0;x<GRID_N;x++) if(grid[y][x]) remain++;
  ctx.fillStyle="#fff"; ctx.font=Math.max(14,Math.floor(CELL*0.35))+"px sans-serif";
  ctx.fillText(`残りマス数：${remain} / ${GRID_N*GRID_N}`,10,40);

  const animMap=new Map(); for(const a of animations) animMap.set(`${a.x},${a.y}`,a);

  for(let y=0;y<GRID_N;y++){
    for(let x=0;x<GRID_N;x++){
      const px=x*CELL, py=y*CELL+TOP_MARGIN;
      const key=`${x},${y}`;
      if(animMap.has(key)){
        const a=animMap.get(key), scale=Math.abs(Math.cos(a.t*Math.PI));
        drawCellScaled(px,py,CELL,CELL,a.newVal,scale,x,y);
      } else {
        drawCellScaled(px,py,CELL,CELL,grid[y][x],1,x,y);
        if(showHint && solution[y][x]===1){
          const inset=Math.max(2,Math.floor(CELL*0.08));
          ctx.fillStyle="rgba(255,255,0,0.4)";
          ctx.fillRect(px+inset, py+inset, CELL-inset*2, CELL-inset*2);
        }
      }
    }
  }

  for(let i=sparkles.length-1;i>=0;i--){
    const sp=sparkles[i]; sp.update(ANIM_DT); sp.draw(ctx);
    if(sp.isDead()) sparkles.splice(i,1);
  }
}

// -----------------------------
// AutoSolve
// -----------------------------
function startAutoSolve(){
  showHint=false; autoSeq=[]; autoIndex=0;
  for(let y=0;y<GRID_N;y++) for(let x=0;x<GRID_N;x++) if(solution[y][x]) autoSeq.push([x,y]);
  autoRun=true;
}

// -----------------------------
// アニメ更新ループ
// -----------------------------
function updateAnimations(){
  for(let a of animations) a.t+=ANIM_DT;
  animations.forEach(a=>{ if(a.t>=1) grid[a.y][a.x]=a.newVal; });
  animations = animations.filter(a=>a.t<1);

  if(animations.length===0) solution = solveGF2(grid);

  if(autoRun && animations.length===0){
    if(autoIndex<autoSeq.length){ const [x,y]=autoSeq[autoIndex]; autoIndex++; pressAt(x,y); }
    else autoRun=false;
  }

  draw();
  requestAnimationFrame(updateAnimations);
}

// -----------------------------
// 入力イベント
// -----------------------------
function handlePointer(x,y){
  const cx=Math.floor(x/CELL), cy=Math.floor((y-TOP_MARGIN)/CELL);
  if(cx>=0 && cx<GRID_N && cy>=0 && cy<GRID_N){ showHint=false; pressAt(cx,cy); }
}

canvas.addEventListener("click",(ev)=>{
  const rect=canvas.getBoundingClientRect();
  handlePointer(ev.clientX-rect.left, ev.clientY-rect.top);
});

canvas.addEventListener("touchstart",(ev)=>{
  ev.preventDefault();
  const rect=canvas.getBoundingClientRect();
  const touch=ev.touches[0];
  handlePointer(touch.clientX-rect.left, touch.clientY-rect.top);
});

document.getElementById("regenBtn").addEventListener("click",()=>{ showHint=false; newBoard(); });
document.getElementById("hintBtn").addEventListener("click",()=>{ showHint=!showHint; draw(); });
document.getElementById("autoBtn").addEventListener("click",()=>{ startAutoSolve(); });
document.getElementById("sizeSel").addEventListener("change",(e)=>{ GRID_N=Number(e.target.value); newBoard(); });
window.addEventListener("resize",()=>{ adjustCanvasSize(); draw(); });

// -----------------------------
// 初期化
// -----------------------------
(function init(){
  GRID_N = Number(document.getElementById("sizeSel").value)||5;
  newBoard();
  updateAnimations();
})();
</script>
</body>
</html>
